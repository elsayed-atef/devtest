param (
    [string]$ConfigFile = "D:\data\housekeeping_config.xml",
    [switch]$Parallel,
    [switch]$DryRun,
    [string]$LogFile = "D:\data\temp\housekeeping.log"
)

# Initialize a queue for log messages
$logQueue = New-Object System.Collections.Concurrent.ConcurrentQueue[System.String]

# Define a function to handle log writing
function Write-Log {
    param (
        [string]$Message,
        [string]$Level = "INFO"
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "$timestamp [$Level] $Message"
    $logQueue.Enqueue($logMessage)
}

# Define a function to periodically write log messages to the log file
function Start-Logging {
    param (
        [string]$LogFile,
        [System.Collections.Concurrent.ConcurrentQueue[System.String]]$Queue
    )

    while ($true) {
        Start-Sleep -Seconds 1

        if ($Queue.IsEmpty -eq $false) {
            while ($Queue.TryDequeue([ref]$logMessage)) {
                try {
                    Add-Content -Path $LogFile -Value $logMessage -ErrorAction Stop
                } catch {
                    Write-Host "Error writing to log file: $_" -ForegroundColor Red
                }
            }
        }
    }
}

# Start the logging thread
$loggingThread = [System.Threading.Thread]::new([System.Threading.ThreadStart]{
    Start-Logging -LogFile $LogFile -Queue $logQueue
})
$loggingThread.IsBackground = $true
$loggingThread.Start()

# Function to perform cleanup
function Perform-Cleanup {
    param (
        [string]$Path,
        [bool]$IncludeSubfolders,
        [string[]]$ExcludePatterns,
        [int]$RetentionDays,
        [bool]$ArchiveBeforeDelete,
        [string]$ArchivePath,
        [switch]$DryRun,
        [string]$LogFile
    )

    Write-Log "Starting cleanup for path: $Path with retention period: $RetentionDays days." -Level "INFO"

    # Calculate retention date
    $RetentionDate = (Get-Date).AddDays(-$RetentionDays)

    # Get files to delete
    $files = Get-ChildItem -Path $Path -Recurse:$IncludeSubfolders -ErrorAction Stop | 
             Where-Object { $_.LastWriteTime -lt $RetentionDate }

    if ($ExcludePatterns) {
        foreach ($pattern in $ExcludePatterns) {
            Write-Log "Excluding files matching pattern: $pattern" -Level "DEBUG"
            $files = $files | Where-Object { $_.FullName -notmatch $pattern }
        }
    }

    if ($DryRun) {
        Write-Log "DryRun mode enabled. No files will be deleted or moved." -Level "DEBUG"
        Write-Log "Files that would be processed:" -Level "DEBUG"
        $files | ForEach-Object { Write-Log $_.FullName -Level "DEBUG" }
        return
    }

    # Archive files if required
    if ($ArchiveBeforeDelete -and $ArchivePath) {
        Write-Log "Archiving files before deletion to $ArchivePath." -Level "INFO"
        foreach ($file in $files) {
            $dest = Join-Path -Path $ArchivePath -ChildPath $file.FullName.TrimStart($Path)
            $destDir = Split-Path $dest
            if (-not (Test-Path $destDir)) {
                New-Item -Path $destDir -ItemType Directory | Out-Null
                Write-Log "Created directory: $destDir" -Level "DEBUG"
            }
            Move-Item -Path $file.FullName -Destination $dest
            Write-Log "Moved $($file.FullName) to $dest" -Level "DEBUG"
        }
    }

    # Report before deletion
    $initialSize = ($files | Measure-Object -Property Length -Sum).Sum / 1MB
    Write-Log "Initial size of files to be deleted: $([math]::round($initialSize, 2)) MB" -Level "INFO"

    # Delete files
    $deletedCount = 0
    foreach ($file in $files) {
        Remove-Item -Path $file.FullName -Force -ErrorAction Stop
        Write-Log "Deleted $($file.FullName)" -Level "DEBUG"
        $deletedCount++
    }

    # Report after deletion
    Write-Log "Deleted $deletedCount files." -Level "INFO"
    $finalSize = (Get-ChildItem -Path $Path -Recurse:$IncludeSubfolders -ErrorAction Stop | Measure-Object -Property Length -Sum).Sum / 1MB
    Write-Log "Final size after deletion: $([math]::round($finalSize, 2)) MB" -Level "INFO"
}

# Import the XML configuration
$xmlConfig = [xml](Get-Content $ConfigFile)

# Sort paths to ensure subfolders are processed before parent folders
$sortedPaths = $xmlConfig.Housekeeping.Paths.Path | Sort-Object -Property { $_.Path.Length } -Descending

$jobs = @()

# Process each path configuration
foreach ($pathConfig in $sortedPaths) {
    $path = $pathConfig.Path
    $enabled = [bool]$pathConfig.Enabled
    $includeSubfolders = [bool]$pathConfig.IncludeSubfolders
    $excludePatterns = $pathConfig.ExcludePatterns.Pattern
    $retentionDays = [int]$pathConfig.RetentionDays
    $archiveBeforeDelete = [bool]$pathConfig.ArchiveBeforeDelete
    $archivePath = $pathConfig.ArchivePath

    if ($enabled) {
        Write-Log "Processing path: $path" -Level "INFO"
        if ($Parallel) {
            $job = Start-Job -ScriptBlock {
                param (
                    $Path,
                    $IncludeSubfolders,
                    $ExcludePatterns,
                    $RetentionDays,
                    $ArchiveBeforeDelete,
                    $ArchivePath,
                    $DryRun,
                    $LogFile
                )
                # Include Write-Log function here
                function Write-Log {
                    param (
                        [string]$Message,
                        [string]$Level = "INFO"
                    )
                    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    $logMessage = "$timestamp [$Level] $Message"
                    $logQueue.Enqueue($logMessage)
                }

                # Include Perform-Cleanup function here
                function Perform-Cleanup {
                    param (
                        [string]$Path,
                        [bool]$IncludeSubfolders,
                        [string[]]$ExcludePatterns,
                        [int]$RetentionDays,
                        [bool]$ArchiveBeforeDelete,
                        [string]$ArchivePath,
                        [switch]$DryRun,
                        [string]$LogFile
                    )

                    Write-Log "Starting cleanup for path: $Path with retention period: $RetentionDays days." -Level "INFO"

                    # Calculate retention date
                    $RetentionDate = (Get-Date).AddDays(-$RetentionDays)

                    # Get files to delete
                    $files = Get-ChildItem -Path $Path -Recurse:$IncludeSubfolders -ErrorAction Stop | 
                             Where-Object { $_.LastWriteTime -lt $RetentionDate }

                    if ($ExcludePatterns) {
                        foreach ($pattern in $ExcludePatterns) {
                            Write-Log "Excluding files matching pattern: $pattern" -Level "DEBUG"
                            $files = $files | Where-Object { $_.FullName -notmatch $pattern }
                        }
                    }

                    if ($DryRun) {
                        Write-Log "DryRun mode enabled. No files will be deleted or moved." -Level "DEBUG"
                        Write-Log "Files that would be processed:" -Level "DEBUG"
                        $files | ForEach-Object { Write-Log $_.FullName -Level "DEBUG" }
                        return
                    }

                    # Archive files if required
                    if ($ArchiveBeforeDelete -and $ArchivePath) {
                        Write-Log "Archiving files before deletion to $ArchivePath." -Level "INFO"
                        foreach ($file in $files) {
                            $dest = Join-Path -Path $ArchivePath -ChildPath $file.FullName.TrimStart($Path)
                            $destDir = Split-Path $dest
                            if (-not (Test-Path $destDir)) {
                                New-Item -Path $destDir -ItemType Directory | Out-Null
                                Write-Log "Created directory: $destDir" -Level "DEBUG"
                            }
                            Move-Item -Path $file.FullName -Destination $dest
                            Write-Log "Moved $($file.FullName) to $dest" -Level "DEBUG"
                        }
                    }

                    # Report before deletion
                    $initialSize = ($files | Measure-Object -Property Length -Sum).Sum / 1MB
                    Write-Log "Initial size of files to be deleted: $([math]::round($initialSize, 2)) MB" -Level "INFO"

                    # Delete files
                    $deletedCount = 0
                    foreach ($file in $files) {
                        Remove-Item -Path $file.FullName -Force -ErrorAction Stop
                        Write-Log "Deleted $($file.FullName)" -Level "DEBUG"
                        $deletedCount++
                    }

                    # Report after deletion
                    Write-Log "Deleted $deletedCount files." -Level "INFO"
                    $finalSize = (Get-ChildItem -Path $Path -Recurse:$IncludeSubfolders -ErrorAction Stop | Measure-Object -Property Length -Sum).Sum / 1MB
                    Write-Log "Final size after deletion: $([math]::round($finalSize, 2)) MB" -Level "INFO"
                }

                Perform-Cleanup -Path $Path -IncludeSubfolders $IncludeSubfolders `
                                -ExcludePatterns $ExcludePatterns `
                                -RetentionDays $RetentionDays `
                                -ArchiveBeforeDelete $ArchiveBeforeDelete `
                                -ArchivePath $ArchivePath `
                                -DryRun $DryRun `
                                -LogFile $LogFile
            } -ArgumentList $path, $includeSubfolders, $excludePatterns, $retentionDays, $archiveBeforeDelete, $archivePath, $DryRun, $LogFile

            $jobs += $job
        } else {
            Perform-Cleanup -Path $path -IncludeSubfolders $includeSubfolders `
                            -ExcludePatterns $excludePatterns `
                            -RetentionDays $retentionDays `
                            -ArchiveBeforeDelete $archiveBeforeDelete `
                            -ArchivePath $archivePath `
                            -DryRun $DryRun `
                            -LogFile $LogFile
        }
    }
}

# Heapdump cleanup
$heapdumpConfig = $xmlConfig.Housekeeping.Heapdump
$heapdumpPath = $heapdumpConfig.Path
$heapdumpRetentionDays = [int]$heapdumpConfig.RetentionDays

if ($heapdumpConfig.Enabled -eq "true") {
    Write-Log "Performing heapdump cleanup for path: $heapdumpPath with retention period: $heapdumpRetentionDays days." -Level "INFO"
    Perform-Cleanup -Path $heapdumpPath -IncludeSubfolders $false `
                    -ExcludePatterns @() `
                    -RetentionDays $heapdumpRetentionDays `
                    -ArchiveBeforeDelete $false `
                    -ArchivePath "" `
                    -DryRun $DryRun `
                    -LogFile $LogFile
}

# Wait for all jobs to finish
if ($Parallel) {
    if ($jobs.Count -gt 0) {
        $jobs | ForEach-Object {
            try {
                $jobResult = Wait-Job -Job $_ -ErrorAction Stop | Receive-Job -ErrorAction Stop
                Write-Log "Job completed successfully: $($_.Id)" -Level "INFO"
                $jobResult
            } catch {
                Write-Log "Failed to complete job $_. Error: $_" -Level "ERROR"
            } finally {
                Remove-Job -Job $_ -ErrorAction SilentlyContinue
            }
        }
    }
}

# Stop logging thread
$loggingThread.Abort()
Write-Log "Housekeeping completed." -Level "INFO"
