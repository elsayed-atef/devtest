param (
    [switch]$DryRun
)

# Load XML Configuration
[xml]$config = Get-Content "D:\data\temp\HousekeepingConfig.xml"

# Extract Global Settings
$logFilePath = $config.HousekeepingConfig.Settings.LogFilePath
$maxLogSizeMB = [int]$config.HousekeepingConfig.Settings.MaxLogSizeMB

# Function to Log Messages with Timestamp and Log Level
function Log-Message {
    param (
        [string]$Level,
        [string]$Message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] $Message"
    $logEntry | Out-File -FilePath $logFilePath -Append
    # Check and rotate log file if needed
    Rotate-Log -logFilePath $logFilePath -maxLogSizeMB $maxLogSizeMB
}

# Function to Perform Log Rotation
function Rotate-Log {
    param (
        [string]$logFilePath,
        [int]$maxLogSizeMB
    )

    if (Test-Path $logFilePath) {
        $logFileSizeMB = (Get-Item $logFilePath).Length / 1MB
        if ($logFileSizeMB -ge $maxLogSizeMB) {
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $archiveFilePath = Join-Path -Path (Split-Path $logFilePath) -ChildPath "housekeeping_$timestamp.log"
            Rename-Item $logFilePath $archiveFilePath
            Compress-Archive -Path $archiveFilePath -DestinationPath "$archiveFilePath.zip"
            Remove-Item $archiveFilePath
        }
    }
}

# Function to Check Exclusions
function Is-Excluded {
    param (
        [string]$path,
        [string[]]$patterns
    )

    foreach ($pattern in $patterns) {
        if ($path -match $pattern) {
            return $true
        }
    }
    return $false
}

# Function to Convert XML Boolean String to PowerShell Boolean
function Convert-XmlBoolean {
    param (
        [string]$xmlValue
    )
    return $xmlValue -eq "true"
}

# Function to Perform Housekeeping
function Perform-Housekeeping {
    param (
        [string]$path,
        [int]$retentionDays,
        [bool]$includeSubfolders,
        [bool]$archiveBeforeDelete,
        [string]$archivePath,
        [string[]]$excludePatterns
    )

    # Get Current Date for Comparison
    $currentDate = Get-Date

    # Get Files and Folders to Cleanup
    $items = Get-ChildItem -Path $path -Recurse:$includeSubfolders

    foreach ($item in $items) {
        # Skip excluded items
        if (Is-Excluded -path $item.FullName -patterns $excludePatterns) {
            continue
        }

        # Determine the item age in days
        if ($item.PSIsContainer) {
            # For folders, use LastAccessTime
            $itemAgeDays = ($currentDate - $item.LastAccessTime).Days
        } else {
            # For files, use LastWriteTime
            $itemAgeDays = ($currentDate - $item.LastWriteTime).Days
        }

        # Log detailed information for debugging
        Log-Message -Level "Debug" -Message "Item: $($item.FullName), Age: $itemAgeDays days."

        if ($itemAgeDays -ge $retentionDays) {
            if ($DryRun) {
                Log-Message -Level "Debug" -Message "Dry Run: Would delete item $($item.FullName)."
                if ($archiveBeforeDelete) {
                    Log-Message -Level "Debug" -Message "Dry Run: Would archive item $($item.FullName) to $archivePath\$($item.Name).zip."
                }
            } else {
                if ($archiveBeforeDelete) {
                    if (-not (Test-Path $archivePath)) {
                        New-Item -ItemType Directory -Path $archivePath | Out-Null
                    }
                    $zipPath = Join-Path -Path $archivePath -ChildPath "$($item.Name).zip"
                    Compress-Archive -Path $item.FullName -DestinationPath $zipPath
                    Log-Message -Level "Info" -Message "Archived item $($item.FullName) to $zipPath."
                }

                # Delete the item
                Remove-Item $item.FullName -Force
                Log-Message -Level "Info" -Message "Deleted item $($item.FullName)."
            }
        }
    }

    # Log Completion of Housekeeping for the Path
    Log-Message -Level "Info" -Message "Completed housekeeping for $path."
}

# Performance Monitoring
$startTime = Get-Date

# Rotate the Log File if Needed
Rotate-Log -logFilePath $logFilePath -maxLogSizeMB $maxLogSizeMB

# Log the Start of the Housekeeping Script
Log-Message -Level "Info" -Message "Housekeeping script started."

# Loop through each Path in the Configuration
foreach ($pathConfig in $config.HousekeepingConfig.Paths.Path) {
    $includeSubfolders = Convert-XmlBoolean -xmlValue $pathConfig.IncludeSubfolders
    $archiveBeforeDelete = Convert-XmlBoolean -xmlValue $pathConfig.ArchiveBeforeDelete

    if ($pathConfig.Enabled -eq "true") {
        Perform-Housekeeping -path $pathConfig.Location `
                            -retentionDays $pathConfig.RetentionDays `
                            -includeSubfolders $includeSubfolders `
                            -archiveBeforeDelete $archiveBeforeDelete `
                            -archivePath $pathConfig.ArchivePath `
                            -excludePatterns $pathConfig.ExcludePatterns.Pattern
    } else {
        Log-Message -Level "Info" -Message "Skipping disabled path $($pathConfig.Location)."
    }
}

# Log the End of the Housekeeping Script
$endTime = Get-Date
$executionTime = $endTime - $startTime
Log-Message -Level "Info" -Message "Housekeeping script completed."
Log-Message -Level "Info" -Message "Script executed in $($executionTime.TotalSeconds) seconds."
