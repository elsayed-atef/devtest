# Define a path for the log file
$LogFilePath = "D:\data\logs\housekeeping.log"

# Function to Log Messages with Timestamp and Log Level
function Log-Message {
    param (
        [string]$Level,
        [string]$Message
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] $Message"
    Add-Content -Path $LogFilePath -Value $logEntry
}

# Function to Check if Current Time is Within Peak Hours
function Is-In-PeakHours {
    param (
        [datetime]$currentTime,
        [array]$timeRanges
    )

    foreach ($range in $timeRanges) {
        try {
            $startTime = [datetime]::ParseExact($range.Start, "HH:mm", $null).TimeOfDay
            $endTime = [datetime]::ParseExact($range.End, "HH:mm", $null).TimeOfDay

            Log-Message -Level "Debug" -Message "Parsed time range start: $startTime, end: $endTime"

            # Check for time range crossing midnight
            if ($endTime -lt $startTime) {
                # Time range crosses midnight
                if ($currentTime.TimeOfDay -ge $startTime -or $currentTime.TimeOfDay -lt $endTime) {
                    Log-Message -Level "Debug" -Message "Current time is within peak hours range (crosses midnight)."
                    return $true
                }
            } else {
                # Normal time range
                if ($currentTime.TimeOfDay -ge $startTime -and $currentTime.TimeOfDay -lt $endTime) {
                    Log-Message -Level "Debug" -Message "Current time is within peak hours range."
                    return $true
                }
            }
        } catch {
            Log-Message -Level "Error" -Message "Failed to parse time. Error: $($_.Exception.Message). Start: $($range.Start), End: $($range.End)"
        }
    }
    Log-Message -Level "Debug" -Message "Current time is outside all peak hours ranges."
    return $false
}

# Function to Check if a Path Should be Excluded
function Should-ExcludePath {
    param (
        [string]$path,
        [array]$excludePatterns
    )

    foreach ($pattern in $excludePatterns) {
        if ($path -like $pattern) {
            Log-Message -Level "Debug" -Message "Path $path is excluded based on pattern $pattern."
            return $true
        }
    }
    return $false
}

# Function to Perform Housekeeping Tasks
function Perform-Housekeeping {
    param (
        [xml]$config,
        [bool]$DryRun
    )

    foreach ($folder in $config.housekeepingconfig.paths.path) {
        $path = $folder.location
        $retentionDays = [int]$folder.RetentionDays
        $includeSubfolders = [bool]$folder.IncludeSubfolders
        $archiveEnabled = [bool]$folder.Archive.Enabled
        $archivePath = $folder.Archive.Path
        $excludePatterns = $folder.ExcludePatterns.Pattern

        if (Should-ExcludePath -path $path -excludePatterns $excludePatterns) {
            Log-Message -Level "Info" -Message "Skipping folder $path based on exclusion patterns."
            continue
        }

        Log-Message -Level "Debug" -Message "Processing folder: $path"
        Log-Message -Level "Debug" -Message "RetentionDays: $retentionDays, IncludeSubfolders: $includeSubfolders, ArchiveEnabled: $archiveEnabled, ArchivePath: $archivePath"

        if (-Not (Test-Path -Path $path)) {
            Log-Message -Level "Error" -Message "Path not found: $path"
            continue
        }

        $files = Get-ChildItem -Path $path -Recurse:$includeSubfolders -File

        if ($files.Count -eq 0) {
            Log-Message -Level "Debug" -Message "No files found in $path"
        }

        foreach ($file in $files) {
            $fileAge = (Get-Date) - $file.LastWriteTime

            Log-Message -Level "Debug" -Message "Processing file: $($file.FullName), Age: $($fileAge.Days) days"

            if ($fileAge.Days -gt $retentionDays) {
                if ($DryRun) {
                    Log-Message -Level "Debug" -Message "Dry Run: Would delete $file"
                } else {
                    Log-Message -Level "Info" -Message "Deleting $file"
                    Remove-Item -Path $file.FullName -Force
                }

                if ($archiveEnabled) {
                    if ($DryRun) {
                        Log-Message -Level "Debug" -Message "Dry Run: Would archive $file to $archivePath"
                    } else {
                        $archiveFile = Join-Path -Path $archivePath -ChildPath $file.Name
                        Log-Message -Level "Info" -Message "Archiving $file to $archivePath"
                        Move-Item -Path $file.FullName -Destination $archiveFile
                    }
                }
            }
        }

        # Check if the folder is empty and delete if necessary
        if ($folder.DeleteIfEmpty -and (Get-ChildItem -Path $path).Count -eq 0) {
            if ($DryRun) {
                Log-Message -Level "Debug" -Message "Dry Run: Would delete empty folder $path"
            } else {
                Log-Message -Level "Info" -Message "Deleting empty folder $path"
                Remove-Item -Path $path -Recurse
            }
        }
    }
}

# Main Loop
while ($true) {
    # Load XML Configuration
    try {
        $config = [xml](Get-Content "HousekeepingConfig.xml")
        Log-Message -Level "Info" -Message "XML configuration loaded successfully."
    } catch {
        Log-Message -Level "Error" -Message "Failed to load XML configuration. Error: $($_.Exception.Message)"
        exit
    }

    # Extract global settings from XML
    $LogFilePath = $config.housekeepingconfig.Settings.LogFilePath
    $MaxLogSizeMB = [int]$config.housekeepingconfig.Settings.MaxLogSizeMB
    $cleanupIntervalHours = [int]$config.housekeepingconfig.Settings.CleanupIntervalHours
    $DryRun = $config.housekeepingconfig.Settings.DryRun -eq "true"

    # Extract Peak Hours settings
    $peakHoursEnabled = $config.housekeepingconfig.Settings.PeakHours.Enabled -eq "true"
    $sleepUntilPeakHoursEnd = $config.housekeepingconfig.Settings.PeakHours.SleepUntilEnd -eq "true"
    $timeRanges = $config.housekeepingconfig.Settings.PeakHours.TimeRange.Range

    Log-Message -Level "Debug" -Message "Peak hours enabled: $peakHoursEnabled"
    Log-Message -Level "Debug" -Message "Sleep until peak hours end: $sleepUntilPeakHoursEnd"
    Log-Message -Level "Debug" -Message "Configured time ranges: $($timeRanges | ForEach-Object { "$($_.Start) to $($_.End)" })"

    # Check if Peak Hours are Enabled and If the Script Needs to Sleep Until Peak Hours End
    $currentTime = Get-Date
    if ($peakHoursEnabled -and (Is-In-PeakHours -currentTime $currentTime -timeRanges $timeRanges)) {
        Log-Message -Level "Info" -Message "Current time is within peak hours."

        if ($sleepUntilPeakHoursEnd) {
            # Calculate the remaining sleep time until the end of the peak hours
            $endPeakHours = $timeRanges | Where-Object {
                $endTime = [datetime]::ParseExact($_.End, "HH:mm", $null).TimeOfDay
                $endTime -gt $currentTime.TimeOfDay
            } | Sort-Object Start | Select-Object -First 1

            if ($endPeakHours) {
                $endTimePeak = [datetime]::ParseExact($endPeakHours.End, "HH:mm", $null).TimeOfDay
                $sleepTime = ($endTimePeak - $currentTime.TimeOfDay).TotalMinutes
                Log-Message -Level "Info" -Message "Sleeping until peak hours end. Sleeping for $sleepTime minutes."
                Start-Sleep -Minutes $sleepTime
                continue
            }
        }
    } else {
        Log-Message -Level "Info" -Message "Current time is outside peak hours or peak hours are disabled."
    }

    # Perform Housekeeping
    Log-Message -Level "Info" -Message "Starting housekeeping tasks..."
    Perform-Housekeeping -config $config -DryRun $DryRun
    Log-Message -Level "Info" -Message "Completed housekeeping tasks."

    # Log rotation check
    if ((Get-Item $LogFilePath).Length -gt ($MaxLogSizeMB * 1MB)) {
        Rename-Item -Path $LogFilePath -NewName "$LogFilePath.$(Get-Date -Format 'yyyyMMddHHmmss').log"
        Log-Message -Level "Info" -Message "Log file rotated."
    }

    # Sleep for configured interval
    Log-Message -Level "Info" -Message "Sleeping for $cleanupIntervalHours hours."
    Start-Sleep -Seconds ($cleanupIntervalHours * 3600)
}
