# Logging Function
function Log-Message {
    param (
        [string]$Level,
        [string]$Message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] $Message"
    Add-Content -Path $LogFilePath -Value $logEntry
}

# Function to Check if Current Time is Within Peak Hours
function Is-In-PeakHours {
    param (
        [datetime]$currentTime,
        [xml]$timeRanges
    )

    foreach ($range in $timeRanges.Range) {
        $startTime = [datetime]::ParseExact($range.Start, "HH:mm", $null)
        $endTime = [datetime]::ParseExact($range.End, "HH:mm", $null)

        if ($currentTime.TimeOfDay -ge $startTime.TimeOfDay -and $currentTime.TimeOfDay -lt $endTime.TimeOfDay) {
            return $true
        }
    }
    return $false
}

# Function to Perform Housekeeping
function Perform-Housekeeping {
    param (
        [xml]$config,
        [bool]$DryRun
    )

    foreach ($pathConfig in $config.HousekeepingConfig.Paths.Path) {
        $enabled = [bool]$pathConfig.Enabled
        if (-not $enabled) {
            Log-Message -Level "Info" -Message "Skipping disabled path: $($pathConfig.Path)"
            continue
        }

        $path = $pathConfig.Path
        $retentionDays = [int]$pathConfig.RetentionDays
        $includeSubfolders = [bool]$pathConfig.IncludeSubfolders
        $archiveEnabled = [bool]$pathConfig.Archive.Enabled
        $archivePath = $pathConfig.Archive.Path

        Log-Message -Level "Info" -Message "Processing path: $path"

        $files = Get-ChildItem -Path $path -Recurse:$includeSubfolders

        foreach ($file in $files) {
            $fileAge = (Get-Date) - $file.LastWriteTime

            if ($fileAge.TotalDays -ge $retentionDays) {
                if ($DryRun) {
                    Log-Message -Level "Info" -Message "Dry run: Would delete file $($file.FullName)"
                } else {
                    if ($archiveEnabled) {
                        if ($DryRun) {
                            Log-Message -Level "Info" -Message "Dry run: Would archive file $($file.FullName)"
                        } else {
                            $destination = Join-Path -Path $archivePath -ChildPath $file.Name
                            Move-Item -Path $file.FullName -Destination $destination
                            Log-Message -Level "Info" -Message "Archived file: $($file.FullName)"
                        }
                    }

                    Remove-Item -Path $file.FullName -Force
                    Log-Message -Level "Info" -Message "Deleted file: $($file.FullName)"
                }
            }
        }

        # Check if the folder is empty and delete if necessary
        if ($pathConfig.DeleteEmptyFolders -and (-not (Get-ChildItem -Path $path))) {
            if ($DryRun) {
                Log-Message -Level "Info" -Message "Dry run: Would delete empty folder $path"
            } else {
                Remove-Item -Path $path -Force
                Log-Message -Level "Info" -Message "Deleted empty folder: $path"
            }
        }
    }
}

# Main Loop
while ($true) {
    # Load XML Configuration
    $config = [xml](Get-Content "HousekeepingConfig.xml")

    # Extract global settings from XML
    $LogFilePath = $config.HousekeepingConfig.Settings.LogFilePath
    $MaxLogSizeMB = [int]$config.HousekeepingConfig.Settings.MaxLogSizeMB
    $cleanupIntervalHours = [int]$config.HousekeepingConfig.Settings.CleanupIntervalHours
    $DryRun = [bool]$config.HousekeepingConfig.Settings.DryRun

    # Check if Peak Hours are Enabled and If the Script Needs to Sleep Until Peak Hours End
    $currentTime = Get-Date
    $peakHoursEnabled = [bool]$config.HousekeepingConfig.Settings.PeakHours.Enabled
    $sleepUntilPeakHoursEnd = [bool]$config.HousekeepingConfig.Settings.PeakHours.SleepUntilEnd
    $timeRanges = $config.HousekeepingConfig.Settings.PeakHours.TimeRange

    if ($peakHoursEnabled -and (Is-In-PeakHours -currentTime $currentTime -timeRanges $timeRanges)) {
        if ($sleepUntilPeakHoursEnd) {
            # Calculate the remaining sleep time until the end of the peak hours
            $endPeakHours = $timeRanges.Range | Where-Object {
                $endTime = [datetime]::ParseExact($_.End, "HH:mm", $null)
                $endTime.TimeOfDay -gt $currentTime.TimeOfDay
            } | Sort-Object Start | Select-Object -First 1

            if ($endPeakHours) {
                $endTimePeak = [datetime]::ParseExact($endPeakHours.End, "HH:mm", $null)
                $sleepTime = ($endTimePeak.TimeOfDay - $currentTime.TimeOfDay).TotalMinutes
                Log-Message -Level "Info" -Message "Sleeping until peak hours end. Sleeping for $sleepTime minutes."
                Start-Sleep -Minutes $sleepTime
                continue
            }
        }
    }

    # Perform Housekeeping
    Log-Message -Level "Info" -Message "Starting housekeeping tasks..."
    Perform-Housekeeping -config $config -DryRun $DryRun
    Log-Message -Level "Info" -Message "Completed housekeeping tasks."

    # Log rotation check
    if ((Get-Item $LogFilePath).Length -gt ($MaxLogSizeMB * 1MB)) {
        Rename-Item -Path $LogFilePath -NewName "$LogFilePath.$(Get-Date -Format 'yyyyMMddHHmmss').log"
        Log-Message -Level "Info" -Message "Log file rotated."
    }

    # Sleep for configured interval
    Log-Message -Level "Info" -Message "Sleeping for $cleanupIntervalHours hours."
    Start-Sleep -Seconds ($cleanupIntervalHours * 3600)
}
