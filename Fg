[CmdletBinding()]
param (
    [string]$ConfigFile = "C:\housekeeping_config.xml",
    [bool]$DryRun = $false
)

# Function to load configuration from XML
function Get-Config {
    param (
        [string]$xmlPath
    )

    if (-not (Test-Path $xmlPath)) {
        throw "Configuration file not found: $xmlPath"
    }

    try {
        [xml]$xml = Get-Content $xmlPath
        Log-Message -message "Loaded XML configuration: $($xml.OuterXml)" -LogFile $LogFile
        return $xml.Housekeeping
    } catch {
        throw "Failed to read or parse the XML file: $_"
    }
}

# Function to log messages with debug level
function Log-Message {
    param (
        [string]$message,
        [string]$LogFile
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp - $message"
    Add-Content -Path $LogFile -Value $logEntry
}

# Function to archive files
function Archive-File {
    param (
        [string]$filePath,
        [string]$archivePath
    )
    try {
        Log-Message -message "Attempting to archive file: $filePath to $archivePath" -LogFile $LogFile
        $archiveDir = Join-Path -Path $archivePath -ChildPath (Split-Path -Leaf $filePath)
        if (-not (Test-Path $archiveDir)) {
            New-Item -ItemType Directory -Path $archiveDir -Force
        }
        Move-Item -Path $filePath -Destination $archiveDir -Force
        Log-Message -message "Archived file: $filePath to $archiveDir" -LogFile $LogFile
    } catch {
        Log-Message -message "Failed to archive file $filePath: $_" -LogFile $LogFile
    }
}

# Function to clean folders
function Clean-Folder {
    param (
        [string]$Path,
        [int]$RetentionDays,
        [bool]$IncludeSubfolders,
        [string[]]$ExcludeFolders,
        [bool]$EnableArchive,
        [string]$ArchivePath
    )

    try {
        Log-Message -message "Cleaning folder: $Path with retention of $RetentionDays days" -LogFile $LogFile
        $currentDate = Get-Date
        $targetDate = $currentDate.AddDays(-$RetentionDays)

        Log-Message -message "Target date for deletion: $targetDate" -LogFile $LogFile

        $filesToDelete = Get-ChildItem -Path $Path -File -Recurse:$IncludeSubfolders |
                         Where-Object { $_.LastWriteTime -lt $targetDate } |
                         Where-Object {
                             $include = $true
                             foreach ($exclude in $ExcludeFolders) {
                                 if ($_.FullName -like "${exclude}*") {
                                     $include = $false
                                     break
                                 }
                             }
                             return $include
                         }

        Log-Message -message "Files to delete: $($filesToDelete.Count)" -LogFile $LogFile

        foreach ($file in $filesToDelete) {
            if ($DryRun) {
                Log-Message -message "Dry Run: Would delete file: $($file.FullName)" -LogFile $LogFile
            } else {
                if ($EnableArchive) {
                    Archive-File -filePath $file.FullName -archivePath $ArchivePath
                } else {
                    Remove-Item -Path $file.FullName -Force
                    Log-Message -message "Deleted file: $($file.FullName)" -LogFile $LogFile
                }
            }
        }
    } catch {
        Log-Message -message "Error cleaning folder $Path: $_" -LogFile $LogFile
    }
}

# Function to clean memory dumps
function Clean-MemoryDumps {
    param (
        [xml]$memoryDumpRules
    )

    try {
        foreach ($rule in $memoryDumpRules.MemoryDumpRule) {
            if ($rule.Enabled -eq 'True') {
                $path = $rule.Path
                $retentionDays = [int]$rule.RetentionDays
                $includeSubfolders = [bool]$rule.IncludeSubfolders

                Log-Message -message "Cleaning memory dumps in: $path with retention of $retentionDays days" -LogFile $LogFile

                if (-not (Test-Path $path)) {
                    Log-Message -message "Memory dump folder not found: $path" -LogFile $LogFile
                    continue
                }

                $currentDate = Get-Date
                $targetDate = $currentDate.AddDays(-$retentionDays)

                Log-Message -message "Target date for memory dumps: $targetDate" -LogFile $LogFile

                $dumpsToDelete = Get-ChildItem -Path $path -File -Recurse:$includeSubfolders |
                                 Where-Object { $_.LastWriteTime -lt $targetDate }

                Log-Message -message "Memory dumps to delete: $($dumpsToDelete.Count)" -LogFile $LogFile

                foreach ($dump in $dumpsToDelete) {
                    if ($DryRun) {
                        Log-Message -message "Dry Run: Would delete memory dump: $($dump.FullName)" -LogFile $LogFile
                    } else {
                        Remove-Item -Path $dump.FullName -Force
                        Log-Message -message "Deleted memory dump: $($dump.FullName)" -LogFile $LogFile
                    }
                }
            }
        }
    } catch {
        Log-Message -message "Error cleaning memory dumps: $_" -LogFile $LogFile
    }
}

# Function to apply housekeeping rules
function Apply-Housekeeping {
    param (
        [xml]$config
    )
    
    try {
        $logFilePath = if ($config.LogFile.Path) { $config.LogFile.Path } else { "D:\data\temp\housekeeping_log.txt" }
        Log-Message -message "Applying housekeeping rules from config: $($config.OuterXml)" -LogFile $LogFile
        
        foreach ($rule in $config.PathRule) {
            if ($rule.Enabled -eq 'True') {
                $path = $rule.Path
                $retentionDays = [int]$rule.RetentionDays
                $includeSubfolders = [bool]$rule.IncludeSubfolders
                $excludeFolders = @()

                if ($rule.ExcludeFolders.ExcludeFolder) {
                    $excludeFolders = $rule.ExcludeFolders.ExcludeFolder | ForEach-Object { $_.InnerText }
                }

                $enableArchive = [bool]$rule.Archive.Enabled
                $archivePath = $rule.Archive.Path

                Log-Message -message "Applying rule: Path=$path, RetentionDays=$retentionDays, IncludeSubfolders=$includeSubfolders, ExcludeFolders=$($excludeFolders -join ', '), EnableArchive=$enableArchive, ArchivePath=$archivePath" -LogFile $LogFile

                # Clean folder based on rule
                Clean-Folder -Path $path -RetentionDays $retentionDays -IncludeSubfolders $includeSubfolders -ExcludeFolders $excludeFolders -EnableArchive $enableArchive -ArchivePath $archivePath
            }
        }
    } catch {
        Log-Message -message "Error applying housekeeping rules: $_" -LogFile $LogFile
    }
}

# Main loop
while ($true) {
    try {
        # Load configuration
        $config = Get-Config -xmlPath $ConfigFile

        # Set parameters from config
        $LogFile = if ($config.LogFile.Path) { $config.LogFile.Path } else { "D:\data\temp\housekeeping_log.txt" }
        $DryRun = [bool]$config.DryRun
        $SleepIntervalHours = [int]$config.SleepIntervalHours

        Log-Message -message "Configuration loaded. LogFile=$LogFile, DryRun=$DryRun, SleepIntervalHours=$SleepIntervalHours" -LogFile $LogFile

        # Start the housekeeping process
        Log-Message -message "Starting housekeeping process" -LogFile $LogFile

        Apply-Housekeeping -config $config

        if ($config.MemoryDumpRules) {
            Clean-MemoryDumps -memoryDumpRules $config.MemoryDumpRules
        }

        Log-Message -message "Housekeeping process completed" -LogFile $LogFile
    } catch {
        Log-Message -message "Error occurred: $_" -LogFile $LogFile
    }

    # Sleep for the specified interval before the next run
    Log-Message -message "Sleeping for $($SleepIntervalHours) hours" -LogFile $LogFile
    Start-Sleep -Seconds ($SleepIntervalHours * 3600)
}
