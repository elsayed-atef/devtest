[CmdletBinding()]
param (
    [string]$ConfigFile = "C:\housekeeping_config.xml",
    [bool]$DryRun = $false
)

# Function to load and parse XML configuration
function Get-Config {
    param (
        [string]$xmlPath
    )

    if (-not (Test-Path $xmlPath)) {
        throw "Configuration file not found: $xmlPath"
    }

    try {
        [xml]$xml = Get-Content $xmlPath
        Log-Message -message "Loaded XML configuration: $($xml.OuterXml)" -LogFile $LogFile
        return $xml
    } catch {
        throw "Failed to read or parse the XML file: $_"
    }
}

# Function to log messages with debug level
function Log-Message {
    param (
        [string]$message,
        [string]$LogFile
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp - $message"
    Add-Content -Path $LogFile -Value $logEntry
}

# Function to archive files
function Archive-File {
    param (
        [string]$filePath,
        [string]$archivePath
    )
    try {
        Log-Message -message "Attempting to archive file: $filePath to $archivePath" -LogFile $LogFile
        $archiveDir = Join-Path -Path $archivePath -ChildPath (Split-Path -Leaf $filePath)
        if (-not (Test-Path $archiveDir)) {
            New-Item -ItemType Directory -Path $archiveDir -Force
        }
        Move-Item -Path $filePath -Destination $archiveDir -Force
        Log-Message -message "Archived file: $filePath to $archiveDir" -LogFile $LogFile
    } catch {
        Log-Message -message "Failed to archive file $filePath: $_" -LogFile $LogFile
    }
}

# Function to clean folders
function Clean-Folder {
    param (
        [string]$Path,
        [int]$RetentionDays,
        [bool]$IncludeSubfolders,
        [string[]]$ExcludeFolders,
        [bool]$EnableArchive,
        [string]$ArchivePath
    )

    try {
        Log-Message -message "Cleaning folder: $Path with retention of $RetentionDays days" -LogFile $LogFile
        $currentDate = Get-Date
        $targetDate = $currentDate.AddDays(-$RetentionDays)

        Log-Message -message "Target date for deletion: $targetDate" -LogFile $LogFile

        $filesToDelete = Get-ChildItem -Path $Path -File -Recurse:$IncludeSubfolders |
                         Where-Object { $_.LastWriteTime -lt $targetDate } |
                         Where-Object {
                             $include = $true
                             foreach ($exclude in $ExcludeFolders) {
                                 if ($_.FullName -like "$exclude*") {
                                     $include = $false
                                     break
                                 }
                             }
                             return $include
                         }

        Log-Message -message "Files to delete: $($filesToDelete.Count)" -LogFile $LogFile

        foreach ($file in $filesToDelete) {
            if ($DryRun) {
                Log-Message -message "Dry Run: Would delete file: $($file.FullName)" -LogFile $LogFile
            } else {
                if ($EnableArchive) {
                    Archive-File -filePath $file.FullName -archivePath $ArchivePath
                } else {
                    Remove-Item -Path $file.FullName -Force
                    Log-Message -message "Deleted file: $($file.FullName)" -LogFile $LogFile
                }
            }
        }
    } catch {
        Log-Message -message "Error cleaning folder $Path: $_" -LogFile $LogFile
    }
}

# Function to clean memory dumps
function Clean-MemoryDumps {
    param (
        [xml]$memoryDumpRules
    )

    try {
        if (-not $memoryDumpRules) {
            Log-Message -message "No memory dump rules provided." -LogFile $LogFile
            return
        }

        foreach ($rule in $memoryDumpRules.MemoryDumpRule) {
            try {
                if ($rule.Enabled -eq 'True') {
                    $path = $rule.Path
                    $retentionDays = [int]$rule.RetentionDays
                    $includeSubfolders = [bool]$rule.IncludeSubfolders

                    Log-Message -message "Cleaning memory dumps in: $path with retention of $retentionDays days" -LogFile $LogFile

                    if (-not (Test-Path $path)) {
                        Log-Message -message "Memory dump folder not found: $path" -LogFile $LogFile
                        continue
                    }

                    $currentDate = Get-Date
                    $targetDate = $currentDate.AddDays(-$retentionDays)

                    Log-Message -message "Target date for memory dumps: $targetDate" -LogFile $LogFile

                    $dumpsToDelete = Get-ChildItem -Path $path -File -Recurse:$includeSubfolders |
                                     Where-Object { $_.LastWriteTime -lt $targetDate }

                    Log-Message -message "Memory dumps to delete: $($dumpsToDelete.Count)" -LogFile $LogFile

                    foreach ($dump in $dumpsToDelete) {
                        if ($DryRun) {
                            Log-Message -message "Dry Run: Would delete memory dump: $($dump.FullName)" -LogFile $LogFile
                        } else {
                            Remove-Item -Path $dump.FullName -Force
                            Log-Message -message "Deleted memory dump: $($dump.FullName)" -LogFile $LogFile
                        }
                    }
                }
            } catch {
                Log-Message -message "Error processing memory dump rule: $_" -LogFile $LogFile
            }
        }
    } catch {
        Log-Message -message "Error cleaning memory dumps: $_" -LogFile $LogFile
    }
}

# Function to apply housekeeping rules
function Apply-Housekeeping {
    param (
        [xml]$config
    )

    try {
        if (-not $config.Housekeeping) {
            throw "Housekeeping section is missing in the configuration."
        }

        $logFilePath = if ($config.Housekeeping.LogFile.Path) { $config.Housekeeping.LogFile.Path } else { "D:\data\temp\housekeeping_log.txt" }
        Log-Message -message "Applying housekeeping rules from config: $($config.OuterXml)" -LogFile $logFilePath

        if ($config.Housekeeping.PathRules -and $config.Housekeeping.PathRules.PathRule) {
            foreach ($rule in $config.Housekeeping.PathRules.PathRule) {
                try {
                    if ($rule.Enabled -eq 'True') {
                        $path = $rule.Path
                        $retentionDays = [int]$rule.RetentionDays
                        $includeSubfolders = [bool]$rule.IncludeSubfolders
                        $excludeFolders = @()

                        if ($rule.ExcludeFolders -and $rule.ExcludeFolders.ExcludeFolder) {
                            $excludeFolders = $rule.ExcludeFolders.ExcludeFolder | ForEach-Object { $_.InnerText.Trim() }
                        }

                        $enableArchive = [bool]$rule.Archive.Enabled
                        $archivePath = $rule.Archive.Path

                        Log-Message -message "Applying rule: Path=$path, RetentionDays=$retentionDays, IncludeSubfolders=$includeSubfolders, ExcludeFolders=$($excludeFolders -join ', '), EnableArchive=$enableArchive, ArchivePath=$archivePath" -LogFile $logFilePath

                        # Clean folder based on rule
                        Clean-Folder -Path $path -RetentionDays $retentionDays -IncludeSubfolders $includeSubfolders -ExcludeFolders $excludeFolders -EnableArchive $enableArchive -ArchivePath $archivePath
                    }
                } catch {
                    Log-Message -message "Error processing path rule: $_" -LogFile $logFilePath
                }
            }
        } else {
            Log-Message -message "No path rules found in configuration." -LogFile $logFilePath
        }

        # Clean memory dumps
        if ($config.Housekeeping.MemoryDumpRules) {
            Clean-MemoryDumps -memoryDumpRules $config.Housekeeping.MemoryDumpRules
        } else {
            Log-Message -message "No memory dump rules found." -LogFile $logFilePath
        }
    } catch {
        Log-Message -message "Error applying housekeeping rules: $_" -LogFile $logFilePath
    }
}

# Main script execution
$xmlConfig = Get-Config -xmlPath $ConfigFile

# Extract settings from XML
$LogFile = $xmlConfig.Housekeeping.LogFile.Path
$DryRun = [bool]$xmlConfig.Housekeeping.DryRun
$SleepIntervalHours = [int]$xmlConfig.Housekeeping.SleepIntervalHours

# Apply housekeeping rules
Apply-Housekeeping -config $xmlConfig

# Sleep for specified interval and repeat
while ($true) {
    Start-Sleep -Seconds ($SleepIntervalHours * 3600)
    Apply-Housekeeping -config $xmlConfig
}
