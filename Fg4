param (
    [switch]$DryRun
)

# Load XML Configuration
[xml]$config = Get-Content "D:\data\temp\HousekeepingConfig.xml"

# Extract Global Settings
$logFilePath = $config.HousekeepingConfig.Settings.LogFilePath
$maxLogSizeMB = [int]$config.HousekeepingConfig.Settings.MaxLogSizeMB

# Function to Log Messages with Timestamp and Log Level
function Log-Message {
    param (
        [string]$Level,
        [string]$Message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] $Message"
    $logEntry | Out-File -FilePath $logFilePath -Append
    # Check and rotate log file if needed
    Rotate-Log -logFilePath $logFilePath -maxLogSizeMB $maxLogSizeMB
}

# Function to Perform Log Rotation
function Rotate-Log {
    param (
        [string]$logFilePath,
        [int]$maxLogSizeMB
    )

    if (Test-Path $logFilePath) {
        $logFileSizeMB = (Get-Item $logFilePath).Length / 1MB
        if ($logFileSizeMB -ge $maxLogSizeMB) {
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $archiveFilePath = Join-Path -Path (Split-Path $logFilePath) -ChildPath "housekeeping_$timestamp.log"
            Rename-Item $logFilePath $archiveFilePath
            Compress-Archive -Path $archiveFilePath -DestinationPath "$archiveFilePath.zip"
            Remove-Item $archiveFilePath
        }
    }
}

# Function to Check Exclusions
function Is-Excluded {
    param (
        [string]$path,
        [string[]]$patterns
    )

    foreach ($pattern in $patterns) {
        if ($path -match $pattern) {
            return $true
        }
    }
    return $false
}

# Function to Convert XML Boolean String to PowerShell Boolean
function Convert-XmlBoolean {
    param (
        [string]$xmlValue
    )
    return $xmlValue -eq "true"
}

# Function to Perform Housekeeping
function Perform-Housekeeping {
    param (
        [string]$path,
        [int]$retentionDays,
        [bool]$includeSubfolders,
        [bool]$archiveBeforeDelete,
        [string]$archivePath,
        [string[]]$excludePatterns,
        [bool]$checkEmptyFolder
    )

    # Get Current Date for Comparison
    $currentDate = Get-Date

    # Initialize counters
    $filesDeleted = 0
    $foldersDeleted = 0

    try {
        # Get Files and Folders to Cleanup
        $items = Get-ChildItem -Path $path -Recurse:$includeSubfolders -ErrorAction Stop
    } catch {
        Log-Message -Level "Error" -Message "Failed to retrieve items from $path. Error: $_"
        return
    }

    foreach ($item in $items) {
        # Skip excluded items
        if (Is-Excluded -path $item.FullName -patterns $excludePatterns) {
            Log-Message -Level "Debug" -Message "Skipped excluded item: $($item.FullName)."
            continue
        }

        if (-not $item.PSIsContainer) {
            # For files, use LastWriteTime
            $itemAgeDays = ($currentDate - $item.LastWriteTime).Days
            if ($itemAgeDays -ge $retentionDays) {
                try {
                    if ($DryRun) {
                        Log-Message -Level "Debug" -Message "Dry Run: Would delete file $($item.FullName)."
                        if ($archiveBeforeDelete) {
                            Log-Message -Level "Debug" -Message "Dry Run: Would archive file $($item.FullName) to $archivePath\$($item.Name).zip."
                        }
                    } else {
                        if ($archiveBeforeDelete) {
                            if (-not (Test-Path $archivePath)) {
                                New-Item -ItemType Directory -Path $archivePath -ErrorAction Stop | Out-Null
                            }
                            $zipPath = Join-Path -Path $archivePath -ChildPath "$($item.Name).zip"
                            Compress-Archive -Path $item.FullName -DestinationPath $zipPath -ErrorAction Stop
                            Log-Message -Level "Info" -Message "Archived file $($item.FullName) to $zipPath."
                        }
                        # Delete the file
                        Remove-Item $item.FullName -Force -ErrorAction Stop
                        $filesDeleted++
                        Log-Message -Level "Info" -Message "Deleted file $($item.FullName)."
                    }
                } catch {
                    Log-Message -Level "Error" -Message "Failed to process file $($item.FullName). Error: $_"
                }
            }
        }
    }

    # Check if folders are empty and apply retention if enabled
    if ($checkEmptyFolder) {
        $folders = Get-ChildItem -Path $path -Directory -Recurse
        foreach ($folder in $folders) {
            if (-not (Get-ChildItem -Path $folder.FullName)) {
                # For empty folders, use LastAccessTime
                $folderAgeDays = ($currentDate - $folder.LastAccessTime).Days
                if ($folderAgeDays -ge $retentionDays) {
                    try {
                        if ($DryRun) {
                            Log-Message -Level "Debug" -Message "Dry Run: Would delete empty folder $($folder.FullName)."
                        } else {
                            # Delete the empty folder
                            Remove-Item $folder.FullName -Force -ErrorAction Stop
                            $foldersDeleted++
                            Log-Message -Level "Info" -Message "Deleted empty folder $($folder.FullName)."
                        }
                    } catch {
                        Log-Message -Level "Error" -Message "Failed to delete empty folder $($folder.FullName). Error: $_"
                    }
                }
            }
        }
    }

    # Log Completion of Housekeeping for the Path
    Log-Message -Level "Info" -Message "Completed housekeeping for $path. Files deleted: $filesDeleted, Folders deleted: $foldersDeleted."
}

# Performance Monitoring
$startTime = Get-Date

# Rotate the Log File if Needed
Rotate-Log -logFilePath $logFilePath -maxLogSizeMB $maxLogSizeMB

# Log the Start of the Housekeeping Script
Log-Message -Level "Info" -Message "Housekeeping script started."

# Loop through each Path in the Configuration
foreach ($pathConfig in $config.HousekeepingConfig.Paths.Path) {
    $includeSubfolders = Convert-XmlBoolean -xmlValue $pathConfig.IncludeSubfolders
    $archiveBeforeDelete = Convert-XmlBoolean -xmlValue $pathConfig.ArchiveBeforeDelete
    $checkEmptyFolder = Convert-XmlBoolean -xmlValue $pathConfig.CheckEmptyFolder

    if ($pathConfig.Enabled -eq "true") {
        Perform-Housekeeping -path $pathConfig.Location `
                            -retentionDays $pathConfig.RetentionDays `
                            -includeSubfolders $includeSubfolders `
                            -archiveBeforeDelete $archiveBeforeDelete `
                            -archivePath $pathConfig.ArchivePath `
                            -excludePatterns $pathConfig.ExcludePatterns.Pattern `
                            -checkEmptyFolder $checkEmptyFolder
    } else {
        Log-Message -Level "Info" -Message "Skipping disabled path $($pathConfig.Location)."
    }
}

# Log the End of the Housekeeping Script
$endTime = Get-Date
$executionTime = $endTime - $startTime
Log-Message -Level "Info" -Message "Housekeeping script completed."
Log-Message -Level "Info" -Message "Script executed in $($executionTime.TotalSeconds) seconds."
