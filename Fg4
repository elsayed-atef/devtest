param (
    [switch]$DryRun
)

# Load XML Configuration
[xml]$config = Get-Content "D:\data\temp\HousekeepingConfig.xml"

# Extract Global Settings
$logFilePath = $config.HousekeepingConfig.Settings.LogFilePath
$maxLogSizeMB = $config.HousekeepingConfig.Settings.MaxLogSizeMB
$interactiveMode = [bool]$config.HousekeepingConfig.Settings.InteractiveMode

# Function to Log Messages with Timestamp and Log Level
function Log-Message {
    param (
        [string]$Level,
        [string]$Message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] $Message"
    $logEntry | Out-File -FilePath $logFilePath -Append
}

# Function to Perform Log Rotation
function Rotate-Log {
    param (
        [string]$logFilePath,
        [int]$maxLogSizeMB
    )

    if (Test-Path $logFilePath) {
        $logFileSizeMB = (Get-Item $logFilePath).Length / 1MB
        if ($logFileSizeMB -ge $maxLogSizeMB) {
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $archiveFilePath = Join-Path -Path (Split-Path $logFilePath) -ChildPath "housekeeping_$timestamp.log"
            Rename-Item $logFilePath $archiveFilePath
            Compress-Archive -Path $archiveFilePath -DestinationPath "$archiveFilePath.zip"
            Remove-Item $archiveFilePath
        }
    }
}

# Function to Check Exclusions
function Is-Excluded {
    param (
        [string]$path,
        [string[]]$patterns
    )

    foreach ($pattern in $patterns) {
        if ($path -match $pattern) {
            return $true
        }
    }
    return $false
}

# Function to Convert XML Boolean String to PowerShell Boolean
function Convert-XmlBoolean {
    param (
        [string]$xmlValue
    )
    return $xmlValue -eq "true"
}

# Function to Perform Housekeeping with Retry Logic
function Perform-Housekeeping {
    param (
        [string]$path,
        [int]$retentionDays,
        [bool]$includeSubfolders,
        [bool]$archiveBeforeDelete,
        [string]$archivePath,
        [bool]$prioritizeLargeFiles,
        [string[]]$excludePatterns
    )

    # Retry logic for transient errors
    $retryCount = 3
    $retryDelay = 5

    for ($i = 0; $i -lt $retryCount; $i++) {
        try {
            # Log the Start of Housekeeping for a Specific Path
            Log-Message -Level "Info" -Message "Starting housekeeping for $path with retention of $retentionDays days."

            # Get Files to Cleanup, Prioritize Large Files if Enabled
            $files = Get-ChildItem -Path $path -Recurse:$includeSubfolders | Where-Object {
                $_.LastWriteTime -lt (Get-Date).AddDays(-$retentionDays) -and
                -not (Is-Excluded -path $_.FullName -patterns $excludePatterns)
            }

            if ($prioritizeLargeFiles) {
                $files = $files | Sort-Object Length -Descending
            }

            foreach ($file in $files) {
                if ($interactiveMode -and -not $DryRun) {
                    $response = Read-Host "Do you want to delete $($file.FullName)? (Y/N)"
                    if ($response -ne 'Y') {
                        Log-Message -Level "Info" -Message "Skipped file $($file.FullName)."
                        continue
                    }
                }

                if ($DryRun) {
                    Log-Message -Level "Debug" -Message "Dry Run: Would delete file $($file.FullName)."
                    if ($archiveBeforeDelete) {
                        Log-Message -Level "Debug" -Message "Dry Run: Would archive file $($file.FullName) to $archivePath\$($file.Name).zip."
                    } else {
                        Log-Message -Level "Debug" -Message "Dry Run: Archiving is disabled; no archive action will be taken."
                    }
                } else {
                    if ($archiveBeforeDelete) {
                        if (-not (Test-Path $archivePath)) {
                            New-Item -ItemType Directory -Path $archivePath | Out-Null
                        }
                        $zipPath = Join-Path -Path $archivePath -ChildPath "$($file.Name).zip"
                        Compress-Archive -Path $file.FullName -DestinationPath $zipPath
                        Log-Message -Level "Info" -Message "Archived file $($file.FullName) to $zipPath."
                    } else {
                        Log-Message -Level "Info" -Message "Archiving is disabled for this path, skipping archive step."
                    }

                    # Delete the file
                    Remove-Item $file.FullName -Force
                    Log-Message -Level "Info" -Message "Deleted file $($file.FullName)."
                }
            }

            # Log Completion of Housekeeping for the Path
            Log-Message -Level "Info" -Message "Completed housekeeping for $path."
            return
        } catch {
            Log-Message -Level "Error" -Message "Error during housekeeping for $path: $_. Exception: $_.Exception.Message"
            if ($i -lt ($retryCount - 1)) {
                Log-Message -Level "Info" -Message "Retrying in $retryDelay seconds..."
                Start-Sleep -Seconds $retryDelay
            } else {
                Log-Message -Level "Error" -Message "Failed after $retryCount attempts. Skipping path $path."
            }
        }
    }
}

# Performance Monitoring
$startTime = Get-Date

# Rotate the Log File if Needed
Rotate-Log -logFilePath $logFilePath -maxLogSizeMB $maxLogSizeMB

# Log the Start of the Housekeeping Script
Log-Message -Level "Info" -Message "Housekeeping script started."

# Loop through each Path in the Configuration
foreach ($pathConfig in $config.HousekeepingConfig.Paths.Path) {
    $includeSubfolders = Convert-XmlBoolean -xmlValue $pathConfig.IncludeSubfolders
    $archiveBeforeDelete = Convert-XmlBoolean -xmlValue $pathConfig.ArchiveBeforeDelete
    $prioritizeLargeFiles = Convert-XmlBoolean -xmlValue $pathConfig.PrioritizeLargeFiles

    if ($pathConfig.Enabled -eq "true") {
        Perform-Housekeeping -path $pathConfig.Location `
                            -retentionDays $pathConfig.RetentionDays `
                            -includeSubfolders $includeSubfolders `
                            -archiveBeforeDelete $archiveBeforeDelete `
                            -archivePath $pathConfig.ArchivePath `
                            -prioritizeLargeFiles $prioritizeLargeFiles `
                            -excludePatterns $pathConfig.ExcludePatterns.Pattern
    } else {
        Log-Message -Level "Info" -Message "Skipping disabled path $($pathConfig.Location)."
    }
}

# Log the End of the Housekeeping Script
$endTime = Get-Date
$executionTime = $endTime - $startTime
Log-Message -Level "Info" -Message "Housekeeping script completed."
Log-Message -Level "Info" -Message "Script executed in $($executionTime.TotalSeconds) seconds."
