# Function to Log Messages with Timestamp and Log Level
function Log-Message {
    param (
        [string]$Level,
        [string]$Message
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] $Message"
    Add-Content -Path $LogFilePath -Value $logEntry
}

# Function to Convert XML Boolean Values to PowerShell Booleans
function Convert-ToBoolean {
    param (
        [string]$value
    )
    if ($value -eq "true") {
        return $true
    } elseif ($value -eq "false") {
        return $false
    } else {
        return $null
    }
}

# Function to Perform Housekeeping Tasks
function Perform-Housekeeping {
    param (
        [xml]$config,
        [bool]$DryRun
    )

    foreach ($folder in $config.HousekeepingConfig.Paths.Path) {
        $path = $folder.Location
        $retentionDays = [int]$folder.RetentionDays
        $includeSubfolders = Convert-ToBoolean $folder.IncludeSubfolders
        $archiveEnabled = Convert-ToBoolean $folder.Archive.Enabled
        $archivePath = $folder.Archive.Path
        $enabled = Convert-ToBoolean $folder.Enabled
        $excludePatterns = $folder.ExcludePatterns.Pattern

        Log-Message -Level "Debug" -Message "Raw XML Values: Location: $path, Enabled: $($folder.Enabled), IncludeSubfolders: $($folder.IncludeSubfolders), ArchiveEnabled: $($folder.Archive.Enabled)"
        Log-Message -Level "Debug" -Message "Parsed Values: Enabled: $enabled, IncludeSubfolders: $includeSubfolders, ArchiveEnabled: $archiveEnabled, RetentionDays: $retentionDays, ArchivePath: $archivePath"
        Log-Message -Level "Debug" -Message "Exclude Patterns: $($excludePatterns -join ', ')"

        if (-not $enabled) {
            Log-Message -Level "Debug" -Message "Skipping folder $path as it is disabled."
            continue
        }

        # Get all files, excluding those matching patterns
        $files = Get-ChildItem -Path $path -Recurse:$includeSubfolders -File | Where-Object {
            $excludePatterns -notcontains $_.Name
        }

        foreach ($file in $files) {
            $fileAge = (Get-Date) - $file.LastWriteTime

            if ($fileAge.Days -gt $retentionDays) {
                if ($DryRun) {
                    Log-Message -Level "Info" -Message "Dry Run: Would delete $($file.FullName)"
                } else {
                    Log-Message -Level "Info" -Message "Deleting $($file.FullName)"
                    Remove-Item -Path $file.FullName -Force
                }

                if ($archiveEnabled) {
                    if ($DryRun) {
                        Log-Message -Level "Info" -Message "Dry Run: Would archive $($file.FullName) to $archivePath"
                    } else {
                        $archiveFile = Join-Path -Path $archivePath -ChildPath $file.Name
                        Log-Message -Level "Info" -Message "Archiving $($file.FullName) to $archivePath"
                        Move-Item -Path $file.FullName -Destination $archiveFile
                    }
                }
            }
        }

        # Check if the folder is empty and delete if necessary
        if ($folder.DeleteIfEmpty -and (Get-ChildItem -Path $path).Count -eq 0) {
            if ($DryRun) {
                Log-Message -Level "Info" -Message "Dry Run: Would delete empty folder $path"
            } else {
                Log-Message -Level "Info" -Message "Deleting empty folder $path"
                Remove-Item -Path $path -Recurse
            }
        }
    }
}

# Main Loop
while ($true) {
    # Load XML Configuration
    $config = [xml](Get-Content "HousekeepingConfig.xml")

    # Extract global settings from XML
    $LogFilePath = $config.HousekeepingConfig.Settings.LogFilePath
    $MaxLogSizeMB = [int]$config.HousekeepingConfig.Settings.MaxLogSizeMB
    $cleanupIntervalHours = [int]$config.HousekeepingConfig.Settings.CleanupIntervalHours
    $DryRun = Convert-ToBoolean $config.HousekeepingConfig.Settings.DryRun

    # Log parsed configuration
    Log-Message -Level "Debug" -Message "Raw XML DryRun Value: $($config.HousekeepingConfig.Settings.DryRun)"
    Log-Message -Level "Debug" -Message "Parsed DryRun Value: $DryRun"
    Log-Message -Level "Debug" -Message "MaxLogSizeMB: $MaxLogSizeMB"
    Log-Message -Level "Debug" -Message "CleanupIntervalHours: $cleanupIntervalHours"

    # Perform Housekeeping
    Log-Message -Level "Info" -Message "Starting housekeeping tasks..."
    Perform-Housekeeping -config $config -DryRun $DryRun
    Log-Message -Level "Info" -Message "Completed housekeeping tasks."

    # Log rotation check
    if ((Get-Item $LogFilePath).Length -gt ($MaxLogSizeMB * 1MB)) {
        Rename-Item -Path $LogFilePath -NewName "$LogFilePath.$(Get-Date -Format 'yyyyMMddHHmmss').log"
        Log-Message -Level "Info" -Message "Log file rotated."
    }

    # Sleep for configured interval
    Log-Message -Level "Info" -Message "Sleeping for $cleanupIntervalHours hours."
    Start-Sleep -Seconds ($cleanupIntervalHours * 3600)
}
